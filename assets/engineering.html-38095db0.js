import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,e}from"./app-2cbc6608.js";const s={},p=e(`<p>为了更好的管理团队，降低管理成本，需要将代码进行统一标准化，为新人或者初级工程师提供便捷的工具，使得其能够更好的发挥自己的作用</p><h2 id="一、模块化和包管理" tabindex="-1"><a class="header-anchor" href="#一、模块化和包管理" aria-hidden="true">#</a> 一、模块化和包管理</h2><h3 id="_1-1-模块化解决了什么问题" tabindex="-1"><a class="header-anchor" href="#_1-1-模块化解决了什么问题" aria-hidden="true">#</a> 1.1 模块化解决了什么问题？</h3><p>模块化的思想为分解和聚合。分解契合的是主观规律，即人为主观的进行分解，降低认识的成本，更好的分析问题。而聚合是客观规律，所见到的大部分都是模块聚合的结果</p><ul><li>函数层面上来看分解和聚合：</li></ul><p>比如说书写一个基本的功能函数，会针对领域内的问题进行细分出来一系列的功能函数（分解），由这些功能函数聚合成要实现的功能（聚合）</p><ul><li>文件层面上的分解和聚合：</li></ul><p>比函数更高一级的分解和聚合，各个文件里有着不同的功能实现，多个文件聚合成一个大的应用场景</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>文件层面上在前端上有两个问题，是 JS 语言层面上的历史原因导致的，分别是：</p><ol><li><p>全局污染，在引用多个 JS 文件时，可能发生的命名冲突，没有隐藏内在实现（分解上的实现问题）</p></li><li><p>依赖混乱，文件与文件之间的依赖关系不明确，随着系统的复杂性增加，为了进行功能解耦，会做许多细化的分解，因此导致文件越来越多，文件之间的依赖关系形成一个巨大的网格（聚合上的实现问题）</p></li></ol></div><p>模块化解决的就是文件层面的分解和聚合，在模块化里面有相应的标准</p><h2 id="_1-2-模块化标准" tabindex="-1"><a class="header-anchor" href="#_1-2-模块化标准" aria-hidden="true">#</a> 1.2 模块化标准</h2><ul><li>CommonJS CJS 民间标准，运行时</li><li>Ecmascript Module ESM 官方标准，编译时</li></ul><p>一个是运行是才知道具体依赖关系，另一个则是在运行前就能知道依赖关系，在编译时就知道了，能方便提前进行优化</p><p>实现层面上：</p><p>有了标准后，根据标准进行实现，也就是语言的运行环境</p><ul><li>浏览器，只支持官方的标准，不支持 CJS</li><li>node，CJS 和 ESM 都支持</li><li>构建工具，模块化的核心应用场景，webpack、rollup、esbuilder，通常 CJS 和 ESM 都支持</li></ul><h2 id="_1-3-包管理" tabindex="-1"><a class="header-anchor" href="#_1-3-包管理" aria-hidden="true">#</a> 1.3 包管理</h2><p>包：package，一系列模块的集合。按照聚合程度的由低到高，从函数到文件再到包</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>框架和库的区别，框架会约束代码的书写规则，而库更偏向于功能上的实现，供开发者调用开发</p></div><p>包管理需要考虑的问题有：</p><ul><li>从哪里下载？</li><li>如何升级？</li><li>如何卸载？</li><li>如何发布？</li><li>版本控制？</li></ul><p>目前前端的包管理方案还是 npm</p><ul><li><p>可以通过 <code>package.json</code> 文件中看到包的相关信息</p></li><li><p>registry 更改包的来源</p></li><li><p>cli(command-line interface) 是包的命令行操作界面</p></li></ul><p>由于企业需求和 npm 的缺陷，也有一些其他的包管理器，如</p><ul><li>pnpm (使用较多)</li><li>yarn</li></ul><h2 id="二、js-工具链" tabindex="-1"><a class="header-anchor" href="#二、js-工具链" aria-hidden="true">#</a> 二、JS 工具链</h2><p>解决语言层面的缺陷和兼容性考虑</p><ul><li>兼容性 <ul><li>语法兼容（可选链，async 等等） <ul><li>syntax transformer(runtime) 语句转换：目前没有大而统一的兼容，一般是一个工具解决一个语法的兼容</li></ul></li><li>API 兼容 <ul><li>polyfill（垫片）: core-js</li></ul></li></ul></li><li>语法增强 <ul><li>jsx 转换工具</li><li>typescript tsc 转换工具</li></ul></li></ul><p>代码转换工具集成各个 JS 工具链，进行统一转换，如 babel</p><p><code>npm i -D @babel/core @babel/cli</code></p><p>babel 会根据源代码生成抽象语法树 AST，再根据 AST 转换成代码，也就是说如果没有扩展的情况下，代码转换后并无变化</p><p>通过插件来修改 AST，从而影响最后的代码生成结果</p><p>书写 babel 的配置文件来定义相关插件，babel 预设里面有常见的插件</p><p>主要用于处理兼容性： <code>npm i -D @babel/preset-env</code></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// babel.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">presets</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&#39;@babel/preset-env&#39;</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、css-工具链" tabindex="-1"><a class="header-anchor" href="#三、css-工具链" aria-hidden="true">#</a> 三、CSS 工具链</h2><p>CSS 中从语言上来说缺少基本循环、判断语句。</p><p>从功能上来说，函数仍有不足，颜色函数、数学函数</p><p>因此有 sass、less、stylus 出现，来增强 css 语言，通过 css 预编译器生成 css</p><p>但这只是语言增强，生成的 css 还有兼容性问题和其他问题</p><ul><li>兼容各个浏览器，厂商前缀</li><li>代码体积压缩</li><li>代码剪枝，去除无用代码</li></ul><p>通过后处理器对 css 进行处理从而符合标准</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>核心其实就是代码转换</p><p>预处理器 -&gt; css -&gt; 后处理器(postCSS) -&gt; css</p><p>postCSS 和 babel 一样，只负责转换代码，通过插件来实现各个功能</p></div><h2 id="四、构建工具和脚手架" tabindex="-1"><a class="header-anchor" href="#四、构建工具和脚手架" aria-hidden="true">#</a> 四、构建工具和脚手架</h2><h3 id="_4-1-构建工具" tabindex="-1"><a class="header-anchor" href="#_4-1-构建工具" aria-hidden="true">#</a> 4.1 构建工具</h3><p>前面二和三说到的都是语言层面上的转换，接下来介绍工程层面上的转换，如何将一个工程目录下的文件转换成传统的<code>html</code>,<code>css</code>,<code>js</code>文件</p><p><code>npm run build</code> 时发生的便是工程的转换</p><p>开发和维护的代码和运行时的代码并不一致，结构也不一致</p><p>运行时的代码需要考虑具体的兼容</p><ul><li><ol><li>哪种工程更适合开发和维护？</li></ol></li><li><ol start="2"><li>哪种工程更适合运行时？传统工程</li></ol></li><li><ol start="3"><li>如何转换（打包）webpack</li></ol></li></ul><p>webpack 做的工作：</p><p>webpack 通过配置的入口区解析字符串，生成 AST，分析依赖关系，进行深层遍历然后打包</p><p>webpack 还能运行本地服务器，从而预览代码效果，不用先打包再去运行打包结果</p><p>文件指纹，打包生成的文件名中带有哈希值，会随着源码的内容改动而改动。涉及到文件缓存，如请求一个 JS 文件，如果有文件指纹的话，当文件内容更新就会产生新的哈希值，从而使得 html 页面（html 一般不会缓存）里的导入该文件的语句发生变化，向服务器发起请求获取该文件。因为文件名不一致，所以会发起新的请求，而如果没有文件指纹，即使服务器文件内容更新了也无法得知，文件名没有发生变化，使用的还是之前的浏览器本地缓存的文件。</p><p>css modules，为了避免类名冲突打包后的 css 类名也发生了变化，如果需要运行时去找到变换后的类名，需要使用导入语句。<code>import styles form &#39;./main.less&#39;</code></p><p>source map，源码地图。将运行时的代码和源代码对应起来，方便调试。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>webpack 的功能并不止上面这些，而开发服务器并不是 webpack 本身的，css modules 时也是专门的库实现的。</p><p>webpack 集成了许多的技术，通过 loader 和 plugin 来实现之前讲到的代码转换和兼容</p></div><h3 id="_4-2-脚手架" tabindex="-1"><a class="header-anchor" href="#_4-2-脚手架" aria-hidden="true">#</a> 4.2 脚手架</h3><ul><li>vue-cli</li><li>vite</li><li>cra</li></ul><p>脚手架负责生成工程目录和配置文件</p><ul><li>提供界面交互</li><li>提供工程模板</li></ul>`,61),n=[p];function c(t,o){return i(),a("div",null,n)}const u=l(s,[["render",c],["__file","engineering.html.vue"]]);export{u as default};
